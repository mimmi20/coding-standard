<?php

declare(strict_types=1);

namespace Laminas\ServiceManager;

use Exception;
use Laminas\ServiceManager\Exception\ContainerModificationsNotAllowedException;
use Laminas\ServiceManager\Exception\CyclicAliasException;
use Laminas\ServiceManager\Exception\InvalidArgumentException;
use Laminas\ServiceManager\Exception\ServiceNotCreatedException;
use Laminas\ServiceManager\Exception\ServiceNotFoundException;
use Laminas\ServiceManager\Proxy\LazyServiceFactory;
use Laminas\Stdlib\ArrayUtils;
use ProxyManager\Configuration as ProxyConfiguration;
use ProxyManager\Factory\LazyLoadingValueHolderFactory;
use ProxyManager\FileLocator\FileLocator;
use ProxyManager\GeneratorStrategy\EvaluatingGeneratorStrategy;
use ProxyManager\GeneratorStrategy\FileWriterGeneratorStrategy;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\ContainerInterface;

use function array_intersect;
use function array_key_exists;
use function array_keys;
use function class_exists;
use function gettype;
use function in_array;
use function is_callable;
use function is_object;
use function is_string;
use function spl_autoload_register;
use function spl_object_hash;
use function sprintf;
use function trigger_error;

use const E_USER_DEPRECATED;

/**
 * Service Manager.
 *
 * Default implementation of the ServiceLocatorInterface, providing capabilities
 * for object creation via:
 *
 * - factories
 * - abstract factories
 * - delegator factories
 * - lazy service factories (generated proxies)
 * - initializers (interface injection)
 *
 * It also provides the ability to inject specific service instances and to
 * define aliases.
 *
 * @see ConfigInterface
 *
 * @psalm-type AbstractFactoriesConfiguration = array<
 *      array-key,
 *      (class-string<Factory\AbstractFactoryInterface>|Factory\AbstractFactoryInterface)
 * >
 * @psalm-type DelegatorsConfiguration = array<
 *      string,
 *      array<
 *          array-key,
 *          (class-string<Factory\DelegatorFactoryInterface>|Factory\DelegatorFactoryInterface)
 *          |callable(ContainerInterface,string,callable():object,array<mixed>|null):object
 *      >
 * >
 * @psalm-type FactoriesConfiguration = array<
 *      string,
 *      (class-string<Factory\FactoryInterface>|Factory\FactoryInterface)
 *      |callable(ContainerInterface,?string,?array<mixed>|null):object
 * >
 * @psalm-type InitializersConfiguration = array<
 *      array-key,
 *      (class-string<Initializer\InitializerInterface>|Initializer\InitializerInterface)
 *      |callable(ContainerInterface,object):void
 * >
 * @psalm-type LazyServicesConfiguration = array{
 *      class_map?:array<string,class-string>,
 *      proxies_namespace?:non-empty-string,
 *      proxies_target_dir?:non-empty-string,
 *      write_proxy_files?:bool
 * }
 * @psalm-type ServiceManagerConfiguration = array{
 *     abstract_factories?: AbstractFactoriesConfiguration,
 *     aliases?: array<string,string>,
 *     delegators?: DelegatorsConfiguration,
 *     factories?: FactoriesConfiguration,
 *     initializers?: InitializersConfiguration,
 *     invokables?: array<string,string>,
 *     lazy_services?: LazyServicesConfiguration,
 *     services?: array<string,object|array>,
 *     shared?:array<string,bool>,
 *     shared_by_default?:bool,
 * }
 *
 * @template InstanceType of object
 * @implements ServiceLocatorInterface<InstanceType>
 */
class ServiceManager implements ServiceLocatorInterface
{
    /** @var Factory\AbstractFactoryInterface[] */
    protected $abstractFactories = [];

    /**
     * A list of aliases
     *
     * Should map one alias to a service name, or another alias (aliases are recursively resolved)
     *
     * @var array<string|class-string<InstanceType>, class-string<InstanceType>>
     */
    protected $aliases = [];

    /**
     * Whether or not changes may be made to this instance.
     *
     * @var bool
     */
    protected $allowOverride = false;

    /** @var ContainerInterface */
    protected $creationContext;

    /**
     * @var string[][]|Factory\DelegatorFactoryInterface[][]
     * @psalm-var DelegatorsConfiguration
     */
    protected $delegators = [];

    /**
     * A list of factories (either as string name or callable)
     *
     * @var string[]|callable[]
     * @psalm-var FactoriesConfiguration
     */
    protected $factories = [];

    /**
     * @var Initializer\InitializerInterface[]|callable[]
     * @psalm-var InitializersConfiguration
     */
    protected $initializers = [];

    /**
     * @var array
     * @psalm-var LazyServicesConfiguration
     */
    protected $lazyServices = [];

    /**
     * A list of already loaded services (this act as a local cache)
     *
     * @var array<string|class-string<InstanceType>,InstanceType>
     */
    protected $services = [];

    /**
     * Enable/disable shared instances by service name.
     *
     * Example configuration:
     *
     * 'shared' => [
     *     MyService::class => true, // will be shared, even if "sharedByDefault" is false
     *     MyOtherService::class => false // won't be shared, even if "sharedByDefault" is true
     * ]
     *
     * @var array<string,bool>
     */
    protected $shared = [];

    /**
     * Should the services be shared by default?
     *
     * @var bool
     */
    protected $sharedByDefault = true;

    /**
     * Service manager was already configured?
     *
     * @var bool
     */
    protected $configured = false;

    /**
     * Cached abstract factories from string.
     * @var array<string, Factory\AbstractFactoryInterface>
     */
    private array $cachedAbstractFactories = [];

    /**
     * See {@see \Laminas\ServiceManager\ServiceManager::configure()} for details
     * on what $config accepts.
     *
     * @phpstan-param array{abstract_factories?: AbstractFactoriesConfiguration, aliases?: array<string,string|class-string<InstanceType>>, delegators?: DelegatorsConfiguration, factories?: FactoriesConfiguration, initializers?: InitializersConfiguration, invokables?: array<string,string>, lazy_services?: LazyServicesConfiguration, services?: array<string|class-string<InstanceType>,InstanceType>, shared?:array<string|class-string<InstanceType>,bool>, shared_by_default?:bool} $config
     */
    public function __construct(array $config = []);

    /**
     * Implemented for backwards compatibility with previous plugin managers only.
     *
     * Returns the creation context.
     *
     * @deprecated since 3.0.0. Factories using 3.0 should use the container
     *     instance passed to the factory instead.
     *
     * @return ContainerInterface
     */
    public function getServiceLocator();

    /**
     * @template T of object
     *
     * @param string $name Identifier of the entry to look for.
     * @psalm-param string|class-string<T> $name
     * @phpstan-param string|class-string<T> $name
     *
     * @return mixed Entry.
     * @psalm-return ($id is class-string<T> ? T : mixed)
     * @phpstan-return ($id is class-string<T> ? T : mixed)
     */
    public function get($name);

    /**
     * @template T of object
     *
     * @param string $name Identifier of the entry to build.
     * @psalm-param string|class-string<T> $name
     * @phpstan-param string|class-string<T> $name
     *
     * @param array<string, mixed>|null $options
     *
     * @return mixed Entry.
     * @psalm-return ($id is class-string<T> ? T : mixed)
     * @phpstan-return ($id is class-string<T> ? T : mixed)
     */
    public function build($name, ?array $options = null);

    /**
     * {@inheritDoc}
     *
     * @param string|class-string<object> $name
     * @return bool
     */
    public function has($name);

    /**
     * Indicate whether or not the instance is immutable.
     *
     * @param bool $flag
     * @return void
     */
    public function setAllowOverride($flag);

    /**
     * Retrieve the flag indicating immutability status.
     *
     * @return bool
     */
    public function getAllowOverride();

    /**
     * @phpstan-param array{abstract_factories?: AbstractFactoriesConfiguration, aliases?: array<string,string|class-string<InstanceType>>, delegators?: DelegatorsConfiguration, factories?: FactoriesConfiguration, initializers?: InitializersConfiguration, invokables?: array<string,string>, lazy_services?: LazyServicesConfiguration, services?: array<string|class-string<InstanceType>,InstanceType>, shared?:array<string|class-string<InstanceType>,bool>, shared_by_default?:bool} $config
     * @return self<InstanceType>
     * @throws ContainerModificationsNotAllowedException If the allow
     *     override flag has been toggled off, and a service instance
     *     exists for a given service.
     */
    public function configure(array $config);

    /**
     * Add an alias.
     *
     * @param string $alias
     * @param string $target
     * @throws ContainerModificationsNotAllowedException If $alias already exists as a service and overrides are disallowed.
     * @return void
     */
    public function setAlias($alias, $target);

    /**
     * Add an invokable class mapping.
     *
     * @param string $name Service name
     * @param null|string $class Class to which to map; if omitted, $name is assumed.
     * @throws ContainerModificationsNotAllowedException If $name already exists as a service and overrides are disallowed.
     * @return void
     */
    public function setInvokableClass($name, $class = null);

    /**
     * Specify a factory for a given service name.
     *
     * @param string $name Service name
     * @param string|callable|Factory\FactoryInterface $factory  Factory to which to map.
     * phpcs:disable Generic.Files.LineLength.TooLong
     * @psalm-param class-string<Factory\FactoryInterface>|callable(ContainerInterface,string,array<mixed>|null):object|Factory\FactoryInterface $factory
     * phpcs:enable Generic.Files.LineLength.TooLong
     * @return void
     * @throws ContainerModificationsNotAllowedException If $name already exists as a service and overrides are disallowed.
     */
    public function setFactory($name, $factory);

    /**
     * Create a lazy service mapping to a class.
     *
     * @param string $name Service name to map
     * @param null|string $class Class to which to map; if not provided, $name will be used for the mapping.
     * @return void
     */
    public function mapLazyService($name, $class = null);

    /**
     * Add an abstract factory for resolving services.
     *
     * @param string|Factory\AbstractFactoryInterface $factory Abstract factory instance or class name.
     * @psalm-param class-string<Factory\AbstractFactoryInterface>|Factory\AbstractFactoryInterface $factory
     * @return void
     */
    public function addAbstractFactory($factory);

    /**
     * Add a delegator for a given service.
     *
     * @param string $name Service name
     * @param string|callable|Factory\DelegatorFactoryInterface $factory Delegator factory to assign.
     * @psalm-param class-string<Factory\DelegatorFactoryInterface>|callable(ContainerInterface,string,callable,array<mixed>|null) $factory
     * @return void
     */
    public function addDelegator($name, $factory);

    /**
     * Add an initializer.
     *
     * @param string|callable|Initializer\InitializerInterface $initializer
     * @psalm-param class-string<Initializer\InitializerInterface>
     *     |callable(ContainerInterface,mixed):void
     *     |Initializer\InitializerInterface $initializer
     * @return void
     */
    public function addInitializer($initializer);

    /**
     * Map a service.
     *
     * @param string|class-string<InstanceType> $name Service name
     * @param InstanceType $service
     * @throws ContainerModificationsNotAllowedException If $name already exists as a service and overrides are disallowed.
     * @return void
     */
    public function setService($name, $service);

    /**
     * Add a service sharing rule.
     *
     * @param string $name Service name
     * @param bool $flag Whether or not the service should be shared.
     * @throws ContainerModificationsNotAllowedException If $name already exists as a service and overrides are disallowed.
     * @return void
     */
    public function setShared($name, $flag);
}
